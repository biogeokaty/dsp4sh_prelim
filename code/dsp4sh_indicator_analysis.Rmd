---
title: "DSP4SH v6 - Indicator Analysis"
author: "Katy Dynarski"
date: "2024-4-12"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Load libraries
library(here)
library(aqp)
library(zoo)
library(janitor)
library(flextable)
library(multcomp)
library(corrr)
library(ggcorrplot)
library(FactoMineR)
library(factoextra)
library(corrplot)
library(lme4)
library(ggeffects)
library(ggrepel)
library(ggspatial)
library(ggeasy)
library(sf)
library(rnaturalearth)
library(rnaturalearthdata)
library(viridis)
library(cowplot)
library(missMDA)
library(ggfortify)
library(scales)
library(metafor)
library(ggpubr)
library(glmulti)
library(sensemakr)
library(tidyverse)

# Load data
project <- read.csv(here("data_processed", "05_project_data.csv"))
surf <- read.csv(here("data_processed","05_surface_horizons.csv"))
meta_df <- read.csv(here("data_processed", "05_meta_df.csv"))

# Make list of summary functions - useful for generating summary tables
mean_sd <- list(
  mean = ~round(mean(.x, na.rm = TRUE), 2), 
  sd = ~round(sd(.x, na.rm = TRUE), 2)
)

min_max <- list(
  min = ~min(.x, na.rm=TRUE), 
  max = ~max(.x, na.rm=TRUE)
)

# Custom ggplot themes
theme_katy <- function(base_size=14) {
  theme_classic(base_size=base_size) %+replace%
    theme(# Legend
      legend.title=element_text(size=rel(1)), legend.text=element_text(size=rel(.8)),
      #axes                      
      axis.text=element_text(size=rel(.8)),
      axis.title=element_text(size=rel(1)))
}

theme_katy_grid <- function(base_size=14) {
  theme_classic(base_size=base_size) %+replace%
    theme(# Legend
      legend.title=element_text(size=rel(1)), legend.text=element_text(size=rel(.8)),
      #axes                      
      axis.text=element_text(size=rel(.8)),
      axis.title=element_text(size=rel(1)),
      # set margins (necessary for figure to not awkwardly overlap when using plot_grid in cowplot)
      plot.margin=unit(c(0.5, 0.5, 0.5, 0.5), "cm"))
}

# Make vector of indicator labels so they will print nicely
indicator_labs <- c("soc_pct" = "SOC %",
                    "soc_stock_100cm" = "SOC stock (100 cm depth)",
                    "soc_stock_0_30cm" = "SOC stock (30 cm depth)",
                    "bglucosaminidase" = "B-glucosaminidase (NAG)",
                    "ace" = "ACE protein",
                    "bglucosidase" = "B-glucosidase (BG)",
                    "kssl_wsa" = "Water-stable aggregates",
                    "yoder_agg_stab_mwd" = "Aggregate mean weight diameter",
                    "arylsulfatase" = "Arylsulfatase (AS)",
                    "pox_c" = "POX-C",
                    "tn_pct" = "Total N%",
                    "bulk_density" = "Bulk density",
                    "soil_respiration" = "Soil respiration",
                    "phosphodiesterase" = "Phosphodiesterase",
                    "alkaline_phosphatase" = "Alkaline phosphatase",
                    "acid_phosphatase" = "Acid phosphatase",
                    "p_h" = "pH")

# Also make into dataframe (need this to use labels within map functions)
indicator_labs_df <- data.frame(indicator_labs) %>%
  rownames_to_column() %>%
  rename(indicator = rowname,
         label = indicator_labs)

# Pivot indicator data longer - needed for many analyses
surf_long <- surf %>%
  select(dsp_pedon_id, soil, project, label, lu, climate, 
         soc_pct, bulk_density, kssl_wsa:yoder_agg_stab_mwd, soil_respiration:acid_phosphatase, arylsulfatase:ace) %>%
  pivot_longer(soc_pct:ace, names_to="indicator", values_to="value")

# Vector for indicator order for consistent plotting
indicator_plotting_order <- c("bulk_density", "kssl_wsa", "yoder_agg_stab_mwd",
                              "soc_pct", "ace", "pox_c",
                              "soil_respiration","bglucosidase", "bglucosaminidase", 
                              "acid_phosphatase", "alkaline_phosphatase", "arylsulfatase")
```

# Project Background Information

## Maps and tables about DSP4SH projects

Map of DSP4SH Projects:

```{r map of DSP4SH sites}
# Download map of USA from NaturalEarth as basemap
usa_ne <- ne_states(country="united states of america")

# Make dataframe for adding project data annotation to map, with just one point for each project label combination, text label describing project
# Write tibble of annotation for each project/label based on project_distinct
annotation <- tibble(project=c(rep("Illinois", 3), 
                               rep("KansasState", 3),
                               rep("NCState", 3),
                               rep("OregonState", 3),
                               rep("TexasA&MPt-1", 3),
                               rep("TexasA&MPt-2", 3),
                               rep("UConn", 3),
                               rep("UTRGV", 2),
                               rep("UnivOfMinnesota", 3),
                               rep("WashingtonState", 3)),
                     label=c(rep(c("BAU", "Ref", "SHM"), 7), "BAU", "Ref", rep(c("BAU", "Ref", "SHM"), 2)),
                     annotation=c("BAU: Conventional and organic corn-soybean rotation",
                                  "Ref: Forest restored in 1990",
                                  "SHM: No-till corn-soybean rotation",
                                  "BAU: Diverse crops with conventional tillage",
                                  "Ref: Native rangeland",
                                  "SHM: No-till diverse crops and cover cropping",
                                  "BAU: Wheat and corn with conventional tillage",
                                  "Ref: Forest",
                                  "SHM: Hayed perennial grass",
                                  "BAU: Ryegrass and Christmas tree with tillage",
                                  "Ref: Timber forest and hazelnut orchard",
                                  "SHM: No-till grass and vineyard",
                                  "BAU: Cropping with conventional tillage",
                                  "Ref: Native rangeland",
                                  "SHM: No-till rye and mixed crops",
                                  "BAU: Wheat and sorghum with conventional tillage",
                                  "Ref: Native perennial forage",
                                  "SHM: No-till wheat and sorghum",
                                  "BAU: Corn with conventional tillage",
                                  "Ref: Forest",
                                  "SHM: No-till corn and hay",
                                  "BAU: Diverse crops with conventional tillage",
                                  "Ref: Native forest",
                                  "BAU: Soybean with conventional tillage",
                                  "Ref: Native rangeland",
                                  "SHM: No-till soybean",
                                  "BAU: Cropping with conventional tillage",
                                  "Ref: Perennial grassland",
                                  "SHM: No-till cropping"))
# Get unique soil series
project_soil <- project %>%
  distinct(project, soil) %>%
  group_by(project) %>%
  mutate(count = paste("soil",seq(n()), sep="_")) %>%
  pivot_wider(names_from=count, values_from=soil) %>%
  unite("soils", soil_1:soil_3, sep=", ", na.rm=TRUE)
flextable(project_soil)

# Make annotation dataframe that includes project, label, soil, and xy coords
project_annotate <- project %>% 
  group_by(project, label) %>%
  mutate(avg_lat = mean(pedon_y, na.rm=TRUE),
         avg_long = mean(pedon_x, na.rm=TRUE)) %>%
  distinct(project, label, avg_lat, avg_long) %>%
  left_join(annotation, by=c("project", "label")) %>%
  left_join(project_soil, by="project")

# Make a dataframe with only one point per project to make the map labels
project_labs <- project_annotate %>%
  group_by(project) %>%
  filter(label=="BAU") %>%
  mutate(name_long = ifelse(project=="Illinois", "University of Illinois",
                            ifelse(project=="OregonState", "Oregon State University",
                                   ifelse(project=="UConn", "University of Connecticut",
                                          ifelse(project=="UTRGV", "University of Texas - Rio Grande Valley",
                                                 ifelse(project=="KansasState", "Kansas State University",
                                                        ifelse(project=="NCState", "North Carolina State University",
                                                               ifelse(project=="TexasA&MPt-1", "Texas A&M - 1",
                                                                      ifelse(project=="TexasA&MPt-2", "Texas A&M - 2",
                                                                             ifelse(project=="UnivOfMinnesota", "University of Minnesota", "Washington State University"))))))))))

# Make map
ggplot(data=usa_ne) +
  geom_sf(fill=NA) +
  coord_sf(xlim=c(-125.0, -66.93457), ylim=c(23.5, 49.384358)) + # set bounding box around CONUS
  annotation_north_arrow(location="bl", which_north="true", height=unit(.25, "in"), width=unit(.25, "in"),
                         pad_x = unit(0.4, "in"), pad_y = unit(0.25, "in"), style=north_arrow_fancy_orienteering) + # add north arrow
  annotation_scale(location = "bl") +
  geom_point(data=project_annotate, aes(x=avg_long, y=avg_lat, color=project)) +
  geom_label_repel(data=project_labs, aes(x=avg_long, y=avg_lat, label=name_long),
                   min.segment.length = 0, seed = 42, box.padding = 0.5) +
  scale_color_viridis(discrete=TRUE) +
  theme_classic() +
  easy_remove_axes() +
  theme(legend.position="none")
```

Generate overview table of project information:

```{r dsp4sh project overview table}
# Average climate data - to be added in to project overview table
site_clim_sum <- project %>%
  group_by(project) %>%
  summarize(across(mat:map, ~ mean(.x, na.rm = TRUE))) %>%
  mutate(mat = round(mat, 1),
         map = round(map, 0))

project_table <- project_annotate %>%
  group_by(project) %>%
  select(project, soils, annotation) %>%
  separate_wider_delim(annotation, delim=": ", names=c("label", "description")) %>%
  ungroup() %>%
  left_join(site_clim_sum, by="project") %>%
  arrange(project, label)
flextable(project_table)
```

Table with more detail on each project treatment:

```{r project and treatment details table}
treatment_table <- meta_df %>%
  select(project, label, lu, trt, explanation) %>%
  distinct() %>%
  arrange(project)
```

## Environmental data tables

Table of range in environmental conditions - this is not for a table but is referenced directly in the text:

```{r range of environmental characteristics across all sites}
site_range_table <- project %>%
  summarize(across(where(is.numeric), min_max)) %>%
  mutate(across(where(is.numeric), ~round(.x, 2))) %>%
  transmute(lat_range= paste(pedon_y_min, pedon_y_max, sep="-"),
         long_range = paste(pedon_x_min, pedon_x_max, sep="-"),
         mat_range = paste(mat_min, mat_max, sep="-"),
         map_range = paste(map_min, map_max, sep="-")) %>%
  pivot_longer(everything())

flextable(site_range_table)

# range in indicator values across all sites

indicator_range_table <- surf_long %>%
  group_by(indicator) %>%
  summarize(across(where(is.numeric), min_max)) %>%
  mutate(across(where(is.numeric), ~round(.x, 2)))
flextable(indicator_range_table)

# range in indicator values in reference sites only
indicator_range_table_ref <- surf_long %>%
  filter(label=="Ref") %>%
  group_by(indicator) %>%
  summarize(across(where(is.numeric), min_max)) %>%
  mutate(across(where(is.numeric), ~round(.x, 2)))
flextable(indicator_range_table_ref)
```

```{r number of studies in each climate}
project %>%
  distinct(project, climate)
```

```{r range in soil clay content}
# Calculate site mean clay%
site_clay <- meta_df %>%
  group_by(project, label) %>%
  summarize(clay_mean = mean(clay_tot_psa, na.rm=TRUE))

clay_min_max <- site_clay %>%
  ungroup() %>%
  na.omit() %>%
  summarize(across(where(is.numeric), min_max)) %>%
  mutate(across(where(is.numeric), ~round(.x, 2)))
```

# Analysis of soil health indicator variability across DSP4SH projects

For most of the analyses here, I will be looking at indicator values in the 0-10 cm depth increment only (0-5 cm and 5-10 cm values were averaged to get 0-10 cm values).

## Boxplots of indicator values across all projects

Start by making boxplots of indicator values across treatments in all projects:

```{r indicator boxplots}
# Make list of indicators for purrr
indicators <- surf_long %>%
  distinct(indicator) %>%
  pull(indicator) %>%
  as.character()

# Generate plots showing boxplots of indicator values under different managements in each project. Each plot shows one indicator
plot_list <- map(.x = indicators,
                 .f = ~{
                   surf_long %>% 
                     filter(indicator == .x) %>%
                     ggplot(aes(x = project, y = value, fill=label)) +
                     geom_boxplot() +
                     labs(x="Project", 
                          y=glue::glue({filter(indicator_labs_df, indicator==.x)$label}), 
                          title=glue::glue("0-10 cm Indicator Values - ", 
                                           {filter(indicator_labs_df, indicator==.x)$label})) +
                     scale_fill_viridis(discrete=TRUE, name="Management") +
                     theme_katy() +
                     theme(axis.text.x = element_text(angle = 45, hjust=1))
                 })
plot_list

# Alternate version where each plot shows one project 
projects <- surf_long %>%
  distinct(project) %>%
  pull(project) %>%
  as.character()

plot_list2 <- map(.x = projects,
                 .f = ~{
                   surf_long %>% 
                     filter(project == .x) %>%
                     ggplot(aes(x=label, y=value, fill=label)) +
                     geom_boxplot() +
                     facet_wrap(vars(indicator), scales="free_y", labeller=labeller(indicator=indicator_labs)) +
                     scale_fill_viridis(discrete=TRUE, name="Management") +
                     labs(x="Management", 
                          title=glue::glue("0-10 cm Indicator Values - ", 
                                           {filter(indicator_labs_df, indicator==.x)$label})) +
                     theme_katy()
                 })

plot_list2
```

Initial takeaways from figures:
- It's difficult to compare indicator values between projects because there is so much variability between projects in terms of response to management and absolute value of the data. 
- Data tend to be all over the place - there's no obvious pattern of indicator values always being higher in a particular treatment. Overall, indicator values are most frequently higher in Ref management but even that is not consistent across indicators/between projects.
- KSSL WSA appears to be one of the more sensitive to management indicators - most consistently higher in Ref systems
- POX-C, SOC also tend to be higher in Ref systems
- Values of soil respiration are really different between projects
- Most indicator values tend to be higher under Ref management in Illinois, Kansas State, NC State, Minnesota projects
- SHM seems to influence several indicators (ACE, POX-C, Yoder MWD, SOC%) in Texas A&M pt 1 project (and values in SHM are actually higher than in Ref)

Make a version of these figures that shows two frequently measured indicators and how their response to management varies across a precipitation gradient.

```{r indicator response to management across precipitation gradient}
# Calculate site mean climate data
site_clim_dist <- project %>%
  distinct(project, climate)

site_clim_sum <- project %>%
  group_by(project) %>%
  summarize(across(mat:map, ~ mean(.x, na.rm = TRUE))) %>%
  left_join(site_clim_dist, by="project")

# Join to soils data
surf_avg_clim <- surf %>%
  left_join(select(site_clim_sum, project, mat, map), by="project", suffix=c("_pedon", "_site"))

# Plot - make one line plot that shows precipitation across sites, then plot on top of boxplots
map_plot <- ggplot(surf_avg_clim, aes(x=fct_reorder(soil, map_site), y=map_site)) +
  geom_point(color="dodgerblue4") +
  geom_line(aes(group=1), color="dodgerblue2") +
  labs(x="Soil", y="MAP (mm)") +
  theme_katy_grid() +
  easy_remove_x_axis() 
  
poxc_box <- ggplot(surf_avg_clim, aes(x=fct_reorder(soil, map_site), y=pox_c, fill=label)) +
  geom_boxplot() +
  labs(x="Soil", y="POX-C") +
  scale_fill_viridis(discrete=TRUE, name="Management") +
  theme_katy_grid() +
  easy_remove_x_axis()

bg_box <- ggplot(surf_avg_clim, aes(x=fct_reorder(soil, map_site), y=bglucosidase, fill=label)) +
  geom_boxplot() +
  labs(x="Soil", y=expression(beta*"-glucosidase")) +
  scale_fill_viridis(discrete=TRUE, name="Management") +
  theme_katy_grid() +
  theme(axis.text.x = element_text(angle = 45, hjust=1))

ind_grid <- plot_grid(map_plot,
          poxc_box + theme(legend.position="none"), 
          bg_box + theme(legend.position="none"), 
          ncol=1, rel_heights=c(.5, 1, 1.25), align="v")

ind_leg <- get_legend(bg_box + theme(legend.box.margin = margin(0, 0, 0, 12)))

ind_full <- plot_grid(ind_grid, ind_leg, rel_widths = c(3, .4))
ind_full
```

Also show a summary table of mean/sd indicator values:

```{r summary table of indicator values}
# table of mean indicator values in reference, SHM, and BAU systems
indicator_summary_wide <- surf_long %>%
  group_by(project, label, indicator) %>%
  summarize(across(value, mean_sd)) %>%
  na.omit() %>%
  unite("summary", value_mean:value_sd) %>%
  pivot_wider(names_from=indicator, values_from=summary)
flextable(indicator_summary_wide)

# table of mean indicator values in reference systems only
indicator_summary_ref <- indicator_summary_wide %>%
  filter(label=="Ref")
flextable(indicator_summary_ref)

# table of mean indicator values by land use
indicator_summary_lu <- surf_long %>%
  group_by(lu, label, indicator) %>%
  summarize(across(value, mean_sd)) %>%
  na.omit() %>%
  unite("summary", value_mean:value_sd) %>%
  pivot_wider(names_from=indicator, values_from=summary)
flextable(indicator_summary_lu)
```

Range in mean indicator values across projects (which indicators were the most variable?):

```{r range in mean indicator values across projects}
indicator_mean_range <- surf_long %>%
  group_by(project, label, indicator) %>%
  summarize(across(value, mean_sd)) %>%
  na.omit() %>%
  ungroup() %>%
  group_by(indicator) %>%
  summarize(across(value_mean, min_max)) %>%
  mutate(fold = value_mean_max/value_mean_min)
flextable(indicator_mean_range)
```

## Use a correlation matrix to look at the structure and covariance of the soil health metrics

In addition to indicator values (and if they are sensitive to treatment), I'm interested in seeing what indicators correlate well with one another and understanding the overall structure of the indicator data. Which indicators tend to "group" together and respond similarly to treatment? Which indicators are not sensitive, or may be contributing different information. 

A few ways to try to get at these questions are correlation matrices and PCA biplots.

Correlation matrix:

``` {r correlation matrix of soil health indicators}
indicators_only <- surf %>%
  select(bulk_density, soc_pct, kssl_wsa:yoder_agg_stab_mwd, soil_respiration:acid_phosphatase, arylsulfatase:ace)
indicators_normalized <- scale(indicators_only)

# Plot correlation matrix - full version
corr_matrix <- cor(indicators_normalized, use="pairwise.complete.obs")
corr_pmat <- cor_pmat(indicators_normalized)
ggcorrplot(corr_matrix, p.mat=corr_pmat, hc.order=TRUE, type="lower", lab=TRUE, insig="blank") +
  scale_x_discrete(labels=indicator_labs) +
  scale_y_discrete(labels=indicator_labs) +
  theme_katy() +
  theme(axis.text.x = element_text(angle = 45, hjust=1),
        axis.title=element_blank())

# Plot a reduced version showing most significantly correlated variables
indicators_red <- indicators_only %>%
  select(soc_pct, kssl_wsa, ace, pox_c, acid_phosphatase, bglucosidase, bglucosaminidase, arylsulfatase) %>%
  scale()

corr_matrix2 <- cor(indicators_red, use="pairwise.complete.obs")
corr_pmat2 <- cor_pmat(indicators_red)
ggcorrplot(corr_matrix2, p.mat=corr_pmat2, type="lower", lab=TRUE, insig="blank") +
  scale_x_discrete(labels=indicator_labs) +
  scale_y_discrete(labels=indicator_labs) +
  theme_katy() +
  theme(axis.text.x = element_text(angle = 45, hjust=1),
        axis.title=element_blank())
```

Takeaways from correlation plot: 
- Besides TN%, ACE is the strongest covariate of SOC (correlation coefficient of 0.9). 
- KSSL water-stable aggregates and POX-C are also decent covariates (correlation coefficients of 0.5 and 0.46, respectively)
- Arylsulfatase is the strongest enzyme covariate with SOC (0.39). Enzyme activities tend to be correlated with each other but not necessarily SOC%.

## Principal Components Analysis  of indicator data

There are a lot of missing values in the indicator data because not every metric was measured by every cooperator. PCA doesn't handle missing values, so I used the missMDA package to impute missing data. The package imputes missing values so that the imputed values have no weight on the results (i.e. just allows the analysis to be completed).

Impute missing data and run PCA of soil health indicators:

```{r impute missing data and run pca of soil health indicators}
nb <- estim_ncpPCA(indicators_only,method.cv = "Kfold", verbose = FALSE) # estimate the number of components from incomplete data
nb$ncp
res.comp <- imputePCA(indicators_only, ncp = nb$ncp)
imp_ind <- res.comp$completeObs
imp_pca <- prcomp(imp_ind, scale.=TRUE)
summary(imp_pca)
```

Plot PCA results:

```{r plot pca results, echo=FALSE}
# Plot loadings using factoextra - this is helpful to be able to see which variables contributed the most to the principal components
pca_loadings <- fviz_pca_var(imp_pca,
                             col.var = "contrib", # Color by contributions to the PC
                             gradient.cols = c("#FCA636FF", "#B12A90FF", "#0D0887FF" ),
                             repel = TRUE     # Avoid text overlapping
)
pca_loadings

# plot PCA biplot colored by soil series
pca_soil <- autoplot(imp_pca, data=surf, colour="soil", size=3,
                     loadings.label = TRUE, loadings.label.size = 4,
                     loadings.label.colour = 'black', loadings.color="black", 
                     loadings.label.repel=TRUE) +
  scale_color_viridis(discrete=TRUE, name="Soil Series", option="magma") +
  geom_hline(yintercept=0, linetype="dashed") +
  geom_vline(xintercept=0, linetype="dashed") +
  theme_katy()
pca_soil
    
# plot pca biplot colored by management
pca_mgmt <- autoplot(imp_pca, data=surf, colour="label", size=3,
                     loadings.label = TRUE, loadings.label.size = 4,
                     loadings.label.colour = 'black', loadings.color="black", 
                     loadings.label.repel=TRUE) +
  scale_color_viridis(discrete=TRUE, name="Management") +
  geom_hline(yintercept=0, linetype="dashed") +
  geom_vline(xintercept=0, linetype="dashed") +
  theme_katy()
pca_mgmt
ggsave(here("figs", "indicators_pca_mgmt.png"), width=8, height=6, units="in")

# Put two together in a grid
plot_grid(pca_soil, pca_mgmt, ncol=1)

# try a PCA grouped by climate
pca_clim <- autoplot(imp_pca, data=surf, colour="climate", size=3) +
  scale_color_viridis(discrete=TRUE, name="Climate") +
  geom_hline(yintercept=0, linetype="dashed") +
  geom_vline(xintercept=0, linetype="dashed") +
  theme_katy()
pca_clim
```

The loadings plot shows that some of the variables that strongly influenced the principal components are bulk density, soil respiration, SOC%, phosphodiesterase, and ACE. A few variables grouped together pretty closely: SOC%, ACE, TN, and KSSL WSA stand out as very close, and most of the enzyme activities are bunched pretty closely together which makes sense. These results are fairly consistent with what we see in the correlation plots, which makes sense. The difference between a correlation plot and a PCA is that the correlation plot is showing correlations between variables, and the PCA is showing correlations between individuals.

I would take this with a grain of salt because there are imputed variables - the loadings plot may be more reflective of which variables had the most real data. 

The first PCA score plot (colored by soil series) shows that the data cluster fairly strongly by soil series. The second PCA score plot (colored by management) shows that the data do not cluster particularly strongly by management. Note - I had tried to show both these things at once by coloring data by soil series and using shape to denote different management, but I personally found it too busy to read on one figure.  

This finding is really consistent with what we see by looking at just the SOC data - soils group much more strongly by soil series than by management groupings. This makes a lot of sense, of course. It is exciting to see that SOC% groups pretty closely with many other variables on the loading plot - many of the soil health metrics we're looking at are likely to reflect something about a soil sample's carbon content.

I also tried a PCA score plot colored by climate. This shows that data cluster fairly strongly by climate. However, I am hesitant to read too much into this, as many climates are represented by only one project. This may really be showing that data cluster strongly by project, which is to be expected (and consistent with analyses so far).

## Identify environmental covariates of indicators

We can try to tease out some of the drivers of variability in indicator values across the dataset - this is helpful to understand if differences in indicator values are driven by soil, climate, land use, etc.

``` {r glmulti to select best model predicting values of each indicator}
# Pivot indicator data (with environmental covariates attached) to longer
ind_long <- meta_df %>%
  select(project, dsp_pedon_id, soil, label, climate, mat, map, lu, till, clay_tot_psa, soc_stock_0_30cm, soc_stock_100cm, 
         soc_pct, bulk_density, kssl_wsa:yoder_agg_stab_mwd, soil_respiration:acid_phosphatase, arylsulfatase:ace) %>%
  pivot_longer(soc_pct:ace, names_to="indicator", values_to="value")

# use glmulti to find best model for each indicator
# then pull out the best model from the weight table, fit linear model, and extract fit metrics and coefficients
multi <- ind_long %>%
  group_by(indicator) %>%
  nest() %>%
  mutate(multi_obj = map(data, ~glmulti("value", c("mat", "map", "lu", "till", "clay_tot_psa"), data=.x,
                                      level = 1, maxsize = 3, confsetsize = 128))) %>%
  mutate(weight = map(multi_obj, ~(weightable(.x) %>% slice_head(n=1)))) %>%
  transmute(indicator, data, weight) %>%
  unnest(cols = c(weight)) %>%
  mutate(lm_obj = map(data, ~lm(model, data=.x))) %>%
  mutate(part_r2 = map(lm_obj, ~as.data.frame(sensemakr::partial_r2(.x)) 
                       %>% rownames_to_column() %>% rename(var = "rowname", partial_r2 = "sensemakr::partial_r2(.x)"))) %>%
  mutate(lm_tidy = map(lm_obj, broom::glance)) %>%
  mutate(lm_coefs = map(lm_obj, broom::tidy)) 

# Make top model for each indicator into a nice table
multi_table <- multi %>%
  ungroup() %>%
  transmute(indicator, model, lm_tidy) %>%
  unnest(cols = c(lm_tidy)) %>%
  mutate(sig = ifelse(p.value<0.05, "significant", "not significant")) %>%
  arrange(desc(adj.r.squared)) %>%
  select(indicator, model, adj.r.squared, p.value, AIC, nobs, sig) %>%
  mutate(across(where(is.numeric), ~ round(.x, 3))) 
flextable(multi_table)

# Pull out the partial R2 values for all models
multi_partials <- multi %>%
  ungroup() %>%
  transmute(indicator, model, lm_tidy, part_r2) %>%
  unnest(cols=c(lm_tidy, part_r2)) %>%
  select(indicator, model, adj.r.squared, var, partial_r2) %>%
  filter(var!="(Intercept)") %>%
  arrange(desc(adj.r.squared)) %>%
  mutate(across(where(is.numeric), ~ round(.x, 2))) 
flextable(multi_partials)
```

``` {r plot partial r2 for significant predictors of each indicator}
# filter data to plot
multi_partials_2plot <- multi_partials %>%
  filter(partial_r2 > 0.1) %>%
  mutate(var = factor(var, levels=c("luRANGE", "luGRASS", "luFOREST", "luFORAGE", "tillPerennial", "clay_tot_psa", "map", "mat")))

# set colors for legend - using BrBG palette
var_fill <- c("mat" = "#35978f",
              "map" = "#80cdc1",
              "clay_tot_psa" = "#c7eae5",
              "tillPerennial" = "#f5f5f5",
              "luFORAGE" = "#f6e8c3",
              "luFOREST" = "#dfc27d",
              "luGRASS" = "#bf812d",
              "luRANGE" = "#8c510a")

# plot
ggplot(multi_partials_2plot, aes(fill=var, 
                                 y=partial_r2, x=fct_relevel(indicator, rev(indicator_plotting_order)))) + 
  geom_bar(position="stack", stat="identity")+
  geom_text(aes(label = partial_r2), size=3, position=position_stack(vjust = 0.5)) +
  labs(x="Indicator", y=expression(Partial~R^2)) +
  scale_x_discrete(labels=indicator_labs) +
  scale_fill_manual(name="Predictor variable", 
                    values=var_fill,
                    labels=c("LU - Rangeland", "LU - Grass", "LU - Forest", "LU - Forage", "Tillage - Untilled Perennial",
                             "Soil Clay %", "MAP", "MAT"),
                    guide = guide_legend(reverse = TRUE),) +
  theme_katy() +
  coord_flip()
```

Takeaways:
- SOC% is the most strongly predicted by environmental and land use covariates - adjusted R2 for the best model was 0.77, and the predictors were MAT, land use, and soil clay %
  -- The strongest individual covariates were MAT (partial R2=0.41) and rangeland land use (partial R2=0.34)
- B-glucosidase was most strongly influenced by MAP (partial R2=0.65)
- KSSL aggregate stability was the indicator most strongly influenced by tillage (partial R2=0.43)
- Acid phosphatase strongly influenced by rangeland land use
- Indicators the least well-predicted by covariates (best models had adjusted R2<0.5): bulk density, alkaline phosphatase, respiration, Yoder aggregate stability, phosphodiesterase, bglucosaminidase (NAG)

## Environmental covariates of indicators in reference sites only

```{r glmulti to select bestmodel - reference sites}
multi_ref <- ind_long %>%
  filter(label=="Ref") %>%
  group_by(indicator) %>%
  nest() %>%
  mutate(multi_obj = map(data, ~glmulti("value", c("mat", "map", "lu", "clay_tot_psa"), data=.x,
                                      level = 1, maxsize = 3, confsetsize = 128))) %>%
  mutate(weight = map(multi_obj, ~(weightable(.x) %>% slice_head(n=1)))) %>%
  transmute(indicator, data, weight) %>%
  unnest(cols = c(weight)) %>%
  mutate(lm_obj = map(data, ~lm(model, data=.x))) %>%
  mutate(part_r2 = map(lm_obj, ~as.data.frame(sensemakr::partial_r2(.x)) 
                       %>% rownames_to_column() %>% rename(var = "rowname", partial_r2 = "sensemakr::partial_r2(.x)"))) %>%
  mutate(lm_tidy = map(lm_obj, broom::glance)) %>%
  mutate(lm_coefs = map(lm_obj, broom::tidy)) 

# Make top model for each indicator into a nice table
multi_table_ref <- multi_ref %>%
  ungroup() %>%
  transmute(indicator, model, lm_tidy) %>%
  unnest(cols = c(lm_tidy)) %>%
  mutate(sig = ifelse(p.value<0.05, "significant", "not significant")) %>%
  arrange(desc(adj.r.squared)) %>%
  select(indicator, model, adj.r.squared, p.value, AIC, nobs, sig) %>%
  mutate(across(where(is.numeric), ~ round(.x, 3))) 
flextable(multi_table_ref)

# Pull out the partial R2 values for all models
multi_partials_ref <- multi_ref %>%
  ungroup() %>%
  transmute(indicator, model, lm_tidy, part_r2) %>%
  unnest(cols=c(lm_tidy, part_r2)) %>%
  select(indicator, model, adj.r.squared, var, partial_r2) %>%
  filter(var!="(Intercept)") %>%
  arrange(desc(adj.r.squared)) %>%
  mutate(across(where(is.numeric), ~ round(.x, 2))) 
flextable(multi_partials_ref)
```

```{r plot partial r2 of significant predictors - reference sites}
multi_partials_2plot_ref <- multi_partials_ref %>%
  filter(partial_r2 > 0.1) %>%
  mutate(var = factor(var, levels=c("luRANGE", "luGRASS", "luFOREST", "clay_tot_psa", "map", "mat")))

var_fill_ref <- c("mat" = "#35978f",
              "map" = "#80cdc1",
              "clay_tot_psa" = "#c7eae5",
              "luFOREST" = "#dfc27d",
              "luGRASS" = "#bf812d",
              "luRANGE" = "#8c510a")

ggplot(multi_partials_2plot_ref, aes(fill=var, 
                    y=partial_r2, x=fct_relevel(indicator, rev(indicator_plotting_order)))) + 
  geom_bar(position="stack", stat="identity")+
  geom_text(aes(label = partial_r2), size=3, position=position_stack(vjust = 0.5)) +
  labs(x="Indicator", y=expression(Partial~R^2)) +
  scale_x_discrete(labels=indicator_labs) +
  scale_fill_manual(name="Predictor variable", 
                    values=var_fill_ref,
                    labels=c("LU - Rangeland", "LU - Grass", "LU - Forest",
                             "Soil Clay %", "MAP", "MAT"),
                    guide = guide_legend(reverse = TRUE),) +
  theme_katy() +
  coord_flip()
```


Takeaways:
- Arylsulfatase was the best predicted by environmental covariates (adjusted R2=0.955), followed by SOC (adjusted R2=0.936) - top model for both included MAP, land use, and soil clay content
- Significant models with R2>0.5 determined for all indicators except for KSSL WSA
- Climate variable (MAT, MAP, or both) was a predictor in most models
- land use also often a strong indicator
- Soil clay content tended to be the least important predictor variable based on partial regression analysis, except for phosphodiesterase and bulk density

# Use meta-analysis methods to determine indicator sensitivity to management across all projects

We're going to treat the DSP4SH database like a meta-analysis and use functions in the metafor() package to calculate the effect size of SHM and Ref treatments on soil health indicators.

## Calculate effect size for individual treatments and plot indicator effect sizes

Prep data for effect size calculation:

```{r prepare data for effect size calculation}
# Pivot data longer
meta_long <- meta_df %>%
  select(project, dsp_pedon_id, soil, label, climate, lu, till, trt, soc_stock_0_30cm, soc_stock_100cm, 
         soc_pct, bulk_density, kssl_wsa:yoder_agg_stab_mwd, soil_respiration:acid_phosphatase, arylsulfatase:ace) %>%
  pivot_longer(soc_stock_0_30cm:ace, names_to="indicator", values_to="value")

# Make a new treatment variable with two values, BAU and ASP. ASP will contain all of the SHM and Ref soils.
meta_long2 <- meta_long %>%
  mutate(treat = ifelse(label=="BAU", "BAU", "ASP"))

# Calculate mean, sd, and n for BAU soils - need this for effect size calculation input
bau_means <- meta_long2 %>%
  filter(treat=="BAU") %>%
  filter(dsp_pedon_id!="BAU9-1") %>% # exclude pedon BAU9-1 from analysis - it's from WashingtonState study and has implausibly high enzyme activity
  group_by(project, indicator) %>%
  nest() %>%
  mutate(
    mean_bau = map_dbl(data, ~mean(.$value, na.rm = TRUE)),
    sd_bau = map_dbl(data, ~sd(.$value, na.rm = TRUE)),
    n_bau = map_dbl(data, ~sum(!is.na(.$value)))) %>%
  select(indicator, project, mean_bau, sd_bau, n_bau) %>%
  ungroup() 

# Calculate mean, sd, and n for Ref and SHM
nested2 <- meta_long2 %>%
  filter(treat=="ASP") %>%
  group_by(indicator, label, project, lu, till, trt) %>%
  nest() %>%
  mutate(
    mean_asp = map_dbl(data, ~mean(.$value, na.rm = TRUE)),
    sd_asp = map_dbl(data, ~sd(.$value, na.rm = TRUE)),
    n_asp = map_dbl(data, ~sum(!is.na(.$value)))) %>%
  select(indicator, label, project, lu, till, trt, mean_asp, sd_asp, n_asp) %>%
  ungroup()

# Put data together. This will be input for escalc() function to calculate effect sizes
es_in_big <- nested2 %>%
  left_join(bau_means, by=c("indicator", "project")) %>%
  na.omit()
flextable(es_in_big) 
```

The resulting absolutely monster table shows the effect size for every single indicator in every single treatment. Yikes.

Calculate effect sizes:

```{r calculate effect sizes}
es_asp1 <- escalc(n1i = n_asp, n2i = n_bau, m1i = mean_asp, m2i = mean_bau, 
                  sd1i = sd_asp, sd2i = sd_bau, data = es_in_big, measure = "ROM")

# Join climate and clay% data to effect size data - these will be used as moderator variables for meta-regression later on
es_asp <- es_asp1 %>%
  na.omit() %>% # omit any rows with NA - this should just be places where NaNs were calculated
  unite("proj_trt", project, trt, remove = FALSE) %>%
  rename(till_orig = till) %>%
  mutate(till = ifelse(till_orig == "Till", "No-till", till_orig)) %>% # fix Texas A&M data that was mislabeled - no-till treatment was coded as Till
  relocate(till, .before=till_orig) %>%
  left_join(site_clim_sum, by="project") %>% # add in climate data
  left_join(site_clay, by=c("project", "label")) # add in clay content
```

Once effect sizes are calculated, they can be used to calculate a random effects model to determine significance of effect sizes.

```{r calculate random effects models for all projects with no moderator variables}
# nest data by indicators and treatment contrasts, calculate random-effects models, extract data from model
es_asp_rma_nomod <- es_asp %>%
  group_by(indicator, label) %>%
  nest() %>%
  mutate(rma_obj = map(data, ~rma(yi, vi, slab = proj_trt, data=.x, method="REML"))) %>%
  mutate(rma_tidy = map(rma_obj, broom::tidy)) %>%
  # make dataframe with effect sizes and variances for individual studies
  mutate(study_df = map(rma_obj, ~data.frame(es = .x$yi,
                                             se= sqrt(.x$vi),
                                             type = "study",
                                             study=.x$slab))) %>%
  # make dataframe with overall random effects model estimate and standard error
  mutate(summary_df = map(rma_obj, ~data.frame(es = .x$b,
                                               se=.x$se,
                                               type= "summary",
                                               study="summary"))) %>%
  # put two dfs together into one that can be used to make a forest plot
  mutate(plot_df = map2(study_df, summary_df, rbind))
```

Generate forest plots for each indicator, and a table of which indicators are significantly influenced by treatment:

```{r forest plots and table of significant indicators}
# pull out plotting data
es_asp_rma_plot_df <- es_asp_rma_nomod %>%
  select(indicator, label, plot_df, rma_tidy) %>%
  ungroup() %>%
  transmute(indicator, label, plot_df, rma_tidy) %>%
  unnest(cols = c(plot_df, rma_tidy), names_sep = "_") %>%
  select(indicator, label, plot_df_es, plot_df_se, plot_df_type, plot_df_study, rma_tidy_p.value) %>%
  rename(es = plot_df_es,
         se = plot_df_se,
         type = plot_df_type,
         study = plot_df_study,
         summary_pval = rma_tidy_p.value)

# make vectors of indicator/label combination
indicator_label2 <- es_asp_rma_plot_df %>% distinct(indicator, label)
indicators2 <- indicator_label2 %>% pull(indicator) %>% as.character
labels2 <- indicator_label2 %>% pull(label) %>% as.character

# make plots - should have the same overall effect sizes for each indicator, but more lines to show the different treatments
plot_list3 <- map2(.x = indicators2,
                  .y=labels2,
                  .f = ~{
                    es_asp_rma_plot_df %>% 
                      filter(indicator == .x, label == .y) %>%
                      ggplot(aes(x=factor(study, levels=rev(study)),y=es,
                                 ymax=es+se,ymin=es-se,size=factor(type),colour=factor(type))) + 
                      geom_pointrange() +
                      coord_flip() + 
                      geom_hline(yintercept=0, lty=2,linewidth=1) +
                      scale_size_manual(values=c(0.5,1)) + 
                      labs(x="Study", y="log response ratio",
                           title=glue::glue({unique(filter(es_asp_rma_plot_df, indicator==.x & label==.y)$indicator)}, 
                                            " - ", {unique(filter(es_asp_rma_plot_df, indicator==.x & label==.y)$label)})) + 
                      scale_colour_manual(values=c("grey","black")) + 
                      theme_katy() +
                      theme(legend.position="none")
                  })

plot_list3
```

Observations from forest plots: 
- Most enzymes tend to be responsive except in Washington State study, though phosphodiesterase is all over the place. 
- Washington State is consistently an outlier on enzyme activity response to management (responds negatively to SHM and Ref vs BAU, in most other studies enzyme activities are higher under SHM and Ref managements)
- Bulk density is higher in Texas A&M Pt 1 reference site
- Bulk density is a little higher on average in SHM systems vs BAU - this might be a no-till thing?
- KSSL water stable aggregates responds positively to SHM and Ref in almost every study (only exception is SHM Kansas State - no change)
- POX-C also almost always is significantly different under different management
- SOC %in 0-5 cm higher under Ref in all studies, effect less pronounced in SHM (and in Kansas State, SHM SOC is slightly lower)
- SOC stocks tend to be a little higher in Ref systems, not really influenced by SHM vs BAU
- POX-C typically quite responsive in Ref systems, less so in SHM
- Soil respiration is wild - no change in some studies, wide range of values in others that center around zero, and very responsive sometimes (University of Minnesota, Oregon State)
- Aggregate stability (Yoder) is higher in Ref and SHM for most studies - interestingly not Texas A&M Pt 1

It's also helpful to plot the overall effect size for each indicator:

```{r plot of summary effect sizes for all indicators}
# make dataframe for plotting
es_rma_summary <- es_asp_rma_plot_df %>%
  filter(type=="summary") %>%
  filter(indicator!="soc_stock_100cm") %>%
  filter(indicator!="soc_stock_0_30cm") %>%
  mutate(sig = ifelse(summary_pval<0.05, "significant", "not significant")) %>%
  select(-study)

ggplot(es_rma_summary, aes(x=fct_relevel(indicator, rev(indicator_plotting_order)), y=es, ymax=es+se, ymin=es-se, color=label)) + 
  geom_pointrange(size=1, linewidth=1) +
  geom_text(aes(label=ifelse(sig=="significant", "*", "")), 
            color="black", position=position_nudge(x=0.25), size=5) +
  coord_flip() + 
  geom_hline(yintercept=0, lty=2,linewidth=1) +
  labs(x="Indicator", y="Log response ratio") +
  scale_x_discrete(labels=indicator_labs) +
  scale_color_viridis(discrete=TRUE, name="Management") +
  theme_katy()

# Make table with n for interpretability
es_rma_n_df <- es_asp_rma_nomod %>%
  select(indicator, label, plot_df) %>%
  filter(indicator!="soc_stock_0_30cm") %>%
  filter(indicator!="soc_stock_100cm") %>%
  ungroup() %>%
  transmute(indicator, label, plot_df) %>%
  unnest(cols = c(plot_df)) %>%
  count(indicator, label, type) %>%
  filter(type=="study") %>%
  select(-type) %>%
  mutate(indicator=factor(indicator, levels=indicator_plotting_order)) %>%
  arrange(indicator, label)
flextable(es_rma_n_df)
```

The indicators with the largest effect sizes are: arylsulfatase, aggregate stability (KSSL), aggregate stability (Yoder MWD), ACE, BG, SOC%, and POX-c.
- Interestingly, the indicators with the biggest effect sizes in the Ref state (arylsulfatase and both aggregate stabilities) are much lower in the SHM state.
- ACE, BG, SOC% and POX-C all have smaller effect sizes (still significant for both treatments) but magnitude of responses is similar between Ref and SHM conditions.

```{r table summarizing overall random effects model}
rma_report_table <- es_asp_rma_nomod %>%
  mutate(report_df = map(rma_obj, ~data.frame(tau2 = .x$tau2,
                                              i2 = .x$I2,
                                              h2 = .x$H2,
                                              q_stat = .x$QE,
                                              q_pval = .x$QEp))) %>%
  select(indicator, label, rma_tidy, report_df) %>%
  ungroup() %>%
  transmute(indicator, label, rma_tidy, report_df) %>%
  unnest(cols = c(rma_tidy, report_df)) %>%
  select(-term, -type) %>%
  filter(indicator!="soc_stock_0_30cm") %>%
  filter(indicator!="soc_stock_100cm") %>%
  mutate(estimate = round(estimate, 3),
         std.error = round(std.error, 3),
         statistic = round(statistic, 2),
         p.value = round(p.value, 3),
         tau2 = round(tau2, 3),
         i2 = round(i2, 2),
         h2 = round(h2, 2),
         q_stat = round(q_stat, 1),
         q_pval = round(q_pval, 3),
         q_sig = ifelse(q_pval<0.05, "significant", "not significant"),
         indicator = factor(indicator, levels=indicator_plotting_order)) %>%
  arrange(indicator, label)
flextable(rma_report_table)
```

## Calculate random-effects models with moderating variables

Our previous random-effects models only determined if indicators were significantly influenced by treatment. However, those models didn't include any moderating variables and couldn't tell us what variables influenced the response of indicators to treatment. Some potential moderating variables of interest are MAT, MAP, land use, and tillage.

### MAT as a moderator variable
```{r random effects model with mat as a moderator variable}
# Calculate random-effects model
es_asp_rma_mat <- es_asp %>%
  group_by(indicator) %>%
  nest() %>%
  mutate(rma_obj = map(data, ~rma(yi, vi, slab = project, mod = ~ mat, data=.x, method="REML"))) %>%
  mutate(rma_tidy = map(rma_obj, broom::tidy))

# Make table for reporting, also include QM test of moderators
mat_rma_report_table <- es_asp_rma_mat %>%
  mutate(report_df = map(rma_obj, ~data.frame(tau2 = .x$tau2,
                                              i2 = .x$I2,
                                              h2 = .x$H2,
                                              r2 = .x$R2,
                                              q_stat = .x$QE,
                                              q_pval = .x$QEp,
                                              q_mod = .x$QM,
                                              q_mod_pval = .x$QMp))) %>%
  select(indicator, rma_tidy, report_df) %>%
  ungroup() %>%
  transmute(indicator, rma_tidy, report_df) %>%
  unnest(cols = c(rma_tidy, report_df)) %>%
  filter(term != "intercept") %>%
  filter(indicator!="soc_stock_0_30cm") %>%
  filter(indicator!="soc_stock_100cm") %>%
  select(-term, -type) %>%
  mutate(q_sig = ifelse(q_pval<0.05, "significant", "not significant"),
         q_mod_sig = ifelse(q_mod_pval<0.05, "significant", "not significant"),
         estimate = round(estimate, 3),
         std.error = round(std.error, 3),
         statistic = round(statistic, 2),
         p.value = round(p.value, 3),
         tau2 = round(tau2, 3),
         i2 = round(i2, 2),
         h2 = round(h2, 2),
         r2 = round(r2, 2),
         q_stat = round(q_stat, 1),
         q_pval = round(q_pval, 3),
         q_mod = round(q_mod, 1),
         q_mod_pval = round(q_mod_pval, 2),
         indicator = factor(indicator, levels=indicator_plotting_order)) %>%
  arrange(indicator)
flextable(mat_rma_report_table)

# Extract significant moderator variables
mat_rma_report_table_sig <- mat_rma_report_table %>%
  filter(q_mod_sig=="significant") 
flextable(mat_rma_report_table_sig)
```

```{r plot mat as a moderator variable}
# MAT - Significant for ACE, acid phosphatase, arylsulfatase, bglucosaminidase, bglucosidase, SOC%

# Make vector of indicators 
mat_indicators <- c("ace", "arylsulfatase", "bglucosaminidase", "bglucosidase", "soc_pct")

# Plot with map function
mat_plots <- map(.x = mat_indicators,
                 .f = ~{
                   es_asp %>% 
                     filter(indicator == .x) %>%
                     ggplot(aes(x=mat, y=yi)) +
                     geom_point(aes(colour=label)) +
                     geom_smooth(method="lm", formula = y~x, color="black") +
                     geom_hline(yintercept=0, linetype="dashed") +
                     stat_cor(aes(label = paste(after_stat(rr.label), after_stat(p.label), sep = "~`,`~")),
                              size=4) +
                     scale_colour_viridis(discrete=TRUE, name="Management") +
                     labs(x=expression("Mean annual temperature"~(degree*C)), y="Log response ratio",
                          title=glue::glue({filter(indicator_labs_df, indicator==.x)$label})) + 
                     theme_katy_grid()
                 })

# Now make into a panel grid with cowplot
mat_ace <- pluck(mat_plots, 1)
mat_aryl <- pluck(mat_plots, 2)
mat_bgm <- pluck(mat_plots, 3)
mat_bg <- pluck(mat_plots, 4)
mat_soc <- pluck(mat_plots, 5)

mat_grid <- plot_grid(mat_ace + theme(legend.position="none", axis.title.x=element_blank()),
                      mat_aryl + theme(legend.position="none", axis.title.y=element_blank(), axis.title.x=element_blank()),
                      mat_bgm + theme(legend.position="none", axis.title.y=element_blank(), axis.title.x=element_blank()),
                      mat_bg + theme(legend.position="none", axis.title.x=element_blank()),
                      mat_soc + theme(legend.position="none", axis.title.y=element_blank()),
                      align = 'vh',
                      labels = c("A", "B", "C", "D", "E"),
                      hjust = -1,
                      nrow = 2)

mat_leg <- get_legend(mat_ace)

plot_grid(mat_grid, mat_leg, rel_widths = c(3, .7))
```

Takeaways:
- MAT is positively correlated with log response ratio for ACE protein, arylsulfatase, NAG, BG, and SOC.

### MAP as a moderator variable

```{r random effects model with map as a moderator variable}
# Calculate random-effects model
es_asp_rma_map <- es_asp %>%
  group_by(indicator) %>%
  nest() %>%
  mutate(rma_obj = map(data, ~rma(yi, vi, slab = project, mod = ~ map, data=.x, method="REML"))) %>%
  mutate(rma_tidy = map(rma_obj, broom::tidy))

# Make table for reporting, also include QM test of moderators
map_rma_report_table <- es_asp_rma_map %>%
  mutate(report_df = map(rma_obj, ~data.frame(tau2 = .x$tau2,
                                              i2 = .x$I2,
                                              h2 = .x$H2,
                                              r2 = .x$R2,
                                              q_stat = .x$QE,
                                              q_pval = .x$QEp,
                                              q_mod = .x$QM,
                                              q_mod_pval = .x$QMp))) %>%
  select(indicator, rma_tidy, report_df) %>%
  ungroup() %>%
  transmute(indicator, rma_tidy, report_df) %>%
  unnest(cols = c(rma_tidy, report_df)) %>%
  filter(term != "intercept") %>%
  filter(indicator!="soc_stock_0_30cm") %>%
  filter(indicator!="soc_stock_100cm") %>%
  select(-term, -type) %>%
  mutate(q_sig = ifelse(q_pval<0.05, "significant", "not significant"),
         q_mod_sig = ifelse(q_mod_pval<0.05, "significant", "not significant"),
         estimate = round(estimate, 3),
         std.error = round(std.error, 3),
         statistic = round(statistic, 2),
         p.value = round(p.value, 3),
         tau2 = round(tau2, 3),
         i2 = round(i2, 2),
         h2 = round(h2, 2),
         r2 = round(r2, 2),
         q_stat = round(q_stat, 1),
         q_pval = round(q_pval, 3),
         q_mod = round(q_mod, 1),
         q_mod_pval = round(q_mod_pval, 2),
         indicator = factor(indicator, levels=indicator_plotting_order)) %>%
  arrange(indicator)
flextable(map_rma_report_table)

# Extract significant moderator variables
map_rma_report_table_sig <- map_rma_report_table %>%
  filter(q_mod_sig=="significant") 
flextable(map_rma_report_table_sig)
```

Takeaways:
- MAP is negatively correlated with effect sizes for alkaline phosphatase and arylsulfatase activities, and POX-C concentration

```{r plot map as a moderator variable}
# MAP is significant for alkaline phosphatase, arylsulfatase, POX-C, and SOC stock 0-30cm
# Make vector of indicators 
map_indicators <- c("alkaline_phosphatase", "arylsulfatase", "pox_c")

# Plot with map function
map_plots <- map(.x = map_indicators,
                 .f = ~{
                   es_asp %>% 
                     filter(indicator == .x) %>%
                     ggplot(aes(x=map, y=yi)) +
                     geom_point(aes(colour=label)) +
                     geom_smooth(method="lm", formula = y~x, color="black") +
                     geom_hline(yintercept=0, linetype="dashed") +
                     stat_cor(aes(label = paste(after_stat(rr.label), after_stat(p.label), sep = "~`,`~")),
                              size=4) +
                     scale_colour_viridis(discrete=TRUE, name="Management") +
                     labs(x=expression("Mean annual precipitation"~(mm~yr^-1)), y="Log response ratio",
                          title=glue::glue({filter(indicator_labs_df, indicator==.x)$label})) + 
                     theme_katy_grid()
                 })

# Now make into a panel grid with cowplot
map_alk <- pluck(map_plots, 1)
map_aryl <- pluck(map_plots, 2)
map_poxc <- pluck(map_plots, 3)

map_grid <- plot_grid(map_alk + theme(legend.position="none", axis.title.x=element_blank()),
                      map_aryl + theme(legend.position="none", axis.title.x=element_blank(), axis.title.y=element_blank()),
                      map_poxc + theme(legend.position="none", axis.title.x=element_blank(), axis.title.y=element_blank()),
                      align = 'vh',
                      labels = c("A", "B", "C"),
                      hjust = -1,
                      nrow = 1)

map_grid_label <- ggdraw(map_grid) +
  draw_label(expression("Mean annual precipitation"~(mm~yr^-1)), color="black", vjust=0, y=0)

map_leg <- get_legend(map_aryl)

plot_grid(map_grid_label, map_leg, rel_widths = c(3, .7))
```

### Land use as a moderator variable
```{r random effects model with land use as a moderator variable}
# Calculate random-effects model
es_asp_rma_lu <- es_asp %>%
  group_by(indicator) %>%
  nest() %>%
  mutate(rma_obj = map(data, ~rma(yi, vi, slab = project, mod = ~ factor(lu), data=.x, method="REML"))) %>%
  mutate(rma_tidy = map(rma_obj, broom::tidy))

# Make table for reporting, also include QM test of moderators
lu_rma_report_table <- es_asp_rma_lu %>%
  mutate(report_df = map(rma_obj, ~data.frame(tau2 = .x$tau2,
                                              i2 = .x$I2,
                                              h2 = .x$H2,
                                              r2 = .x$R2,
                                              q_stat = .x$QE,
                                              q_pval = .x$QEp,
                                              q_mod = .x$QM,
                                              q_mod_pval = .x$QMp))) %>%
  select(indicator, rma_tidy, report_df) %>%
  ungroup() %>%
  transmute(indicator, rma_tidy, report_df) %>%
  unnest(cols = c(rma_tidy, report_df)) %>%
  filter(term != "intercept") %>%
  filter(indicator!="soc_stock_0_30cm") %>%
  filter(indicator!="soc_stock_100cm") %>%
  select(-type) %>%
  mutate(q_sig = ifelse(q_pval<0.05, "significant", "not significant"),
         q_mod_sig = ifelse(q_mod_pval<0.05, "significant", "not significant"),
         estimate = round(estimate, 3),
         std.error = round(std.error, 3),
         statistic = round(statistic, 2),
         p.value = round(p.value, 3),
         tau2 = round(tau2, 3),
         i2 = round(i2, 2),
         h2 = round(h2, 2),
         r2 = round(r2, 2),
         q_stat = round(q_stat, 1),
         q_pval = round(q_pval, 3),
         q_mod = round(q_mod, 1),
         q_mod_pval = round(q_mod_pval, 2),
         indicator = factor(indicator, levels=indicator_plotting_order)) %>%
  arrange(indicator)
flextable(lu_rma_report_table)

# Extract significant moderator variables
lu_rma_report_table_sig <- lu_rma_report_table %>%
  filter(q_mod_sig=="significant") 
flextable(lu_rma_report_table_sig)
```

```{r plot land use as a moderator variable}
lu_indicators_df <- lu_rma_report_table_sig %>%
  distinct(indicator)
lu_indicators <- as.vector(lu_indicators_df$indicator)

lu_plots <- map(.x = lu_indicators,
                .f = ~{
                  es_asp %>% 
                    filter(indicator == .x) %>%
                    ggplot(aes(x=lu, y=yi, fill=label)) +
                    geom_boxplot() +
                    geom_hline(yintercept=0, linetype="dashed") +
                    labs(x="Land use", y="Log response ratio",
                         title=glue::glue({filter(indicator_labs_df, indicator==.x)$label})) + 
                    scale_fill_viridis(discrete=TRUE, name="Management") +
                    theme_katy_grid()
                })

# Now make into a panel grid with cowplot
lu_bd <- pluck(lu_plots, 1)
lu_kssl <- pluck(lu_plots, 2)
lu_resp <- pluck(lu_plots, 3)
lu_alk <- pluck(lu_plots, 4)

lu_grid <- plot_grid(lu_bd + theme(legend.position="none", 
                                    axis.title.x=element_blank(), axis.text.x=element_text(angle=45, hjust=1)),
                     lu_kssl + theme(legend.position="none", axis.title.x=element_blank(),
                                    axis.title.y=element_blank(), axis.text.x=element_text(angle=45, hjust=1)), 
                     lu_resp + theme(legend.position="none",  
                                   axis.title.x=element_blank(), axis.text.x=element_text(angle=45, hjust=1)),
                     lu_alk + theme(legend.position="none", axis.title.y=element_blank(),
                                   axis.title.x=element_blank(), axis.text.x=element_text(angle=45, hjust=1)),
                     align = 'vh',
                     labels = c("A", "B", "C", "D"),
                     hjust = -1,
                     nrow = 2, ncol = 2)

lu_grid_label <- ggdraw(lu_grid) +
  draw_label("Land use", color="black", vjust=0, y=0)

lu_leg <- get_legend(lu_alk + theme(legend.box.margin = margin(0, 0, 0, 12)))

plot_grid(lu_grid_label, lu_leg, rel_widths = c(3, .7))
```

Takeaways:
- Land use is a little more nuanced than SHM vs Ref. These data show that for several indicators (bulk density, KSSL WSA, respiration, alkaline phosphatase, phosphodiesterase, N%), the response is significantly different in different land uses within a label.
For example, respiration is slightly higher in SHM vs BAU for crop systems, but slightly lower for forage systems. The response ratio of respiration is much higher in forest systems vs rangeland systems.

### Tillage as a moderator variable

```{r random effects model with tillage as a moderator variable}
es_asp_rma_till <- es_asp %>%
  group_by(indicator) %>%
  nest() %>%
  mutate(rma_obj = map(data, ~rma(yi, vi, slab = project, mod = ~ factor(till), data=.x, method="REML"))) %>%
  mutate(rma_tidy = map(rma_obj, broom::tidy))

# Make table for reporting, also include QM test of moderators
till_rma_report_table <- es_asp_rma_till %>%
  mutate(report_df = map(rma_obj, ~data.frame(tau2 = .x$tau2,
                                              i2 = .x$I2,
                                              h2 = .x$H2,
                                              r2 = .x$R2,
                                              q_stat = .x$QE,
                                              q_pval = .x$QEp,
                                              q_mod = .x$QM,
                                              q_mod_pval = .x$QMp))) %>%
  select(indicator, rma_tidy, report_df) %>%
  ungroup() %>%
  transmute(indicator, rma_tidy, report_df) %>%
  unnest(cols = c(rma_tidy, report_df)) %>%
  filter(term != "intercept") %>%
  filter(indicator!="soc_stock_0_30cm") %>%
  filter(indicator!="soc_stock_100cm") %>%
  select(-type) %>%
  mutate(q_sig = ifelse(q_pval<0.05, "significant", "not significant"),
         q_mod_sig = ifelse(q_mod_pval<0.05, "significant", "not significant"),
         estimate = round(estimate, 3),
         std.error = round(std.error, 3),
         statistic = round(statistic, 2),
         p.value = round(p.value, 3),
         tau2 = round(tau2, 3),
         i2 = round(i2, 2),
         h2 = round(h2, 2),
         r2 = round(r2, 2),
         q_stat = round(q_stat, 1),
         q_pval = round(q_pval, 3),
         q_mod = round(q_mod, 1),
         q_mod_pval = round(q_mod_pval, 2),
         indicator = factor(indicator, levels=indicator_plotting_order)) %>%
  arrange(indicator)
flextable(till_rma_report_table)

# Extract significant moderator variables
till_rma_report_table_sig <- till_rma_report_table %>%
  filter(q_mod_sig=="significant") 
flextable(till_rma_report_table_sig)
```

```{r plot tillage as a moderator variable}
# Tillage is significant for bulk density, KSSL WSA, Yoder WSA, and alkaline phosphatase
till_indicators <- c("bulk_density", "kssl_wsa", "yoder_agg_stab_mwd", "alkaline_phosphatase")

till_plots <- map(.x = till_indicators,
                .f = ~{
                  es_asp %>% 
                    filter(indicator == .x) %>%
                    ggplot(aes(x=till, y=yi, fill=label)) +
                    geom_boxplot() +
                    geom_hline(yintercept=0, linetype="dashed") +
                    labs(x="Tillage", y="Log response ratio",
                         title=glue::glue({filter(indicator_labs_df, indicator==.x)$label})) + 
                    scale_fill_viridis(discrete=TRUE, name="Management") +
                    theme_katy_grid()
                })

till_bd <- pluck(till_plots, 1)
till_kssl <- pluck(till_plots, 2)
till_yod <- pluck(till_plots, 3)
till_alk <- pluck(till_plots, 4)

till_grid <- plot_grid(till_bd + theme(legend.position="none", 
                                   axis.title.x=element_blank(), axis.text.x=element_text(angle=45, hjust=1)),
                     till_kssl + theme(legend.position="none", axis.title.x=element_blank(),
                                     axis.title.y=element_blank(), axis.text.x=element_text(angle=45, hjust=1)), 
                     till_yod + theme(legend.position="none", 
                                      axis.title.x=element_blank(), axis.text.x=element_text(angle=45, hjust=1)),
                     till_alk + theme(legend.position="none", axis.title.x=element_blank(),
                                      axis.title.y=element_blank(), axis.text.x=element_text(angle=45, hjust=1)),
                     align = 'vh',
                     labels = c("A", "B", "C", "D"),
                     hjust = -1,
                     nrow = 2)

till_grid_label <- ggdraw(till_grid) +
  draw_label("Tillage", color="black", vjust=0, y=0)

till_leg <- get_legend(till_alk + theme(legend.box.margin = margin(0, 0, 0, 12)))

plot_grid(till_grid_label, till_leg, rel_widths = c(3, .7))
```

Takeaways:
- It makes sense that tillage is a significant moderator variable for the indicators related to soil physical structure - bulk density, aggregate stability (both KSSL and Yoder)
- Why is Yoder MWD lower in perennial SHM systems vs BAU??

### Clay content as a moderator variable

```{r random effects model with clay% as a moderator variable}
# Calculate random-effects model
es_asp_rma_clay <- es_asp %>%
  group_by(indicator) %>%
  nest() %>%
  mutate(rma_obj = map(data, ~rma(yi, vi, slab = project, mod = ~ clay_mean, data=.x, method="REML"))) %>%
  mutate(rma_tidy = map(rma_obj, broom::tidy))

# Make table for reporting, also include QM test of moderators
clay_rma_report_table <- es_asp_rma_clay %>%
  mutate(report_df = map(rma_obj, ~data.frame(tau2 = .x$tau2,
                                              i2 = .x$I2,
                                              h2 = .x$H2,
                                              r2 = .x$R2,
                                              q_stat = .x$QE,
                                              q_pval = .x$QEp,
                                              q_mod = .x$QM,
                                              q_mod_pval = .x$QMp))) %>%
  select(indicator, rma_tidy, report_df) %>%
  ungroup() %>%
  transmute(indicator, rma_tidy, report_df) %>%
  unnest(cols = c(rma_tidy, report_df)) %>%
  filter(term != "intercept") %>%
  filter(indicator!="soc_stock_0_30cm") %>%
  filter(indicator!="soc_stock_100cm") %>%
  select(-term, -type) %>%
  mutate(q_sig = ifelse(q_pval<0.05, "significant", "not significant"),
         q_mod_sig = ifelse(q_mod_pval<0.05, "significant", "not significant"),
         estimate = round(estimate, 3),
         std.error = round(std.error, 3),
         statistic = round(statistic, 2),
         p.value = round(p.value, 3),
         tau2 = round(tau2, 3),
         i2 = round(i2, 2),
         h2 = round(h2, 2),
         r2 = round(r2, 2),
         q_stat = round(q_stat, 1),
         q_pval = round(q_pval, 3),
         q_mod = round(q_mod, 1),
         q_mod_pval = round(q_mod_pval, 2),
         indicator = factor(indicator, levels=indicator_plotting_order)) %>%
  arrange(indicator)
flextable(clay_rma_report_table)
```

Clay content is missing from 7 studies, so even though the QM test is significant for bulk density, Yoder MWD, SOC%, and ACE, I don't trust reporting that information.